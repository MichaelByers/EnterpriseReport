<!DOCTYPE html>
<html>
<head>
    <title>Enterprise Release App</title>
    
    <script type="text/javascript" src="https://rally1.rallydev.com/apps/2.0p5/sdk.js"></script>
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.6.1.min.js"></script>

    <script type="text/javascript" src="https://raw.github.com/lmaccherone/Lumenize/v0.4.8/deploy/Lumenize-min.js"></script>   

    <script type="text/javascript">
        Rally.onReady(function() {

            (function() {
              // from BurnChart.js, customized
        	  // Generated by CoffeeScript 1.4.0
        	  var ChartTime, burnCalculator, lumenize, root, timeSeriesCalculator, utils,
        	   	__indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

        	  root = this;

        	  if (typeof exports !== "undefined" && exports !== null) {
        	   	lumenize = require('../lib/lumenize');
        	  } else {
        	   	lumenize = require('/lumenize');
        	  }

        	  ChartTime = lumenize.ChartTime, timeSeriesCalculator = lumenize.timeSeriesCalculator;

        	  utils = lumenize.utils;

        	  burnCalculator = function(results, config) {
        	    /*
        	      Takes the "results" from a query to Rally's Analytics API (or similar MVCC-based implementation)
        	      and returns the series for burn charts.
        	    */

        	    var aggregationAtArray, aggregationSpec, categories, ct, derivedFields, f, field, granularity, i, idealData, idealStep, listOfAtCTs, maxTaskEstimateTotal, name, originalPointCount, pastEnd, rangeSpec, s, series, seriesFound, seriesNames, start, timeSeriesCalculatorConfig, type, yAxis, _i, _j, _len, _ref, _ref1, _ref2;
                var todayIndex = -1;
                rIndex = [];
        	    if (config.granularity != null) {
        	      granularity = config.granularity;
        	    } else {
        	      granularity = 'day';
        	    }
                var todayCT = new ChartTime(config.today, granularity, config.workspaceConfiguration.TimeZone);
                var rDates = [];
                for(var i = 0; i<config.rDates.length; i++){
                	rDates[i] = new ChartTime(config.rDates[i], granularity, config.workspaceConfiguration.TimeZone);
                }	
        	    start = config.start;
                start = new ChartTime(start, granularity, config.workspaceConfiguration.TimeZone);
        	    pastEnd = new ChartTime(config.end, granularity, config.workspaceConfiguration.TimeZone).add(1);
        	    rangeSpec = {
        	      workDays: config.workspaceConfiguration.WorkDays,
        	      holidays: config.holidays,
        	      start: start,
        	      pastEnd: pastEnd
        	    };
        	    if (config.upSeriesType == null) {
        	      config.upSeriesType = 'Sums';
        	    }
        	    derivedFields = [];
        	    if (config.upSeriesType === 'Points') {
        	      derivedFields.push({
        	        name: 'Accepted',
        	        f: function(row) {
        	          var _ref;
        	          if (_ref = row.ScheduleState, __indexOf.call(config.acceptedStates, _ref) >= 0) {
        	            return row.PlanEstimate;
        	          } else {
        	            return 0;
        	          }
        	        }
        	      });
        	    } else if (config.upSeriesType === 'Story Count') {
        	      derivedFields.push({
        	        name: 'Accepted',
        	        f: function(row) {
        	          var _ref;
        	          if (_ref = row.ScheduleState, __indexOf.call(config.acceptedStates, _ref) >= 0) {
        	            return 1;
        	          } else {
        	            return 0;
        	          }
        	        }
        	      });
        	    } else {
        	      console.error("Unrecognized upSeriesType: " + config.upSeriesType);
        	    }
        	    seriesNames = [];
        	    aggregationSpec = [];
        	    _ref = config.series;
        	    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        	      s = _ref[_i];
        	      seriesFound = true;
        	      switch (s) {
        	        case 'down':
        	          name = 'Task To Do (Hours)';
        	          f = '$sum';
        	          field = 'TaskRemainingTotal';
        	          yAxis = 0;
        	          type = 'column';
        	          break;
        	        case 'ideal':
        	          name = "Ideal (Hours)";
        	          f = '$sum';
        	          field = 'TaskEstimateTotal';
        	          yAxis = 0;
        	          type = 'line';
        	          break;
        	        case 'up':
        	          name = "Accepted (" + config.upSeriesType + ")";
        	          f = '$sum';
        	          field = 'Accepted';
                      yAxis = 0;
                      type = 'area';
        	          break;
        	        case 'scope':
        	          name = "Scope (" + config.upSeriesType + ")";
        	          if (config.upSeriesType === 'Story Count') {
        	            f = '$count';
        	          } else if (config.upSeriesType === 'Points') {
        	            f = '$sum';
        	          }
        	          field = 'PlanEstimate';
                      yAxis = 0;
        	          type = 'line';
                      break;
                    // ideal projected burn up line
                    case 'projection':
                        name = "Ideal (Points)";
                        f = '$sum';
                        field = 'Ideal';
                        yAxis = 0;
                        type = 'line';
                        break;
                    // release date markers
                    case 'rDates':
                        name = "Release";
                        f = '$sum';
                        field = 'Release';
                        yAxis = 0;
                        type = 'area';
                        break;
        	        default:
        	          if ((s.name != null) && (s.f != null) && (s.field != null)) {
        	            name = s.name;
        	            f = s.f;
        	            field = s.field;
        	            type = 'column';
        	          } else {
        	            seriesFound = false;
        	            console.error("Unrecognizable series: " + s);
        	          }
        	      }
        	      if (seriesFound) {
        	        aggregationSpec.push({
        	          name: name,
        	          as: name,
        	          f: f,
        	          field: field,
        	          yAxis: yAxis,
        	          type: type
        	        });
        	        seriesNames.push(name);
        	      }
        	    }
        	    timeSeriesCalculatorConfig = {
        	      rangeSpec: rangeSpec,
        	      derivedFields: derivedFields,
        	      aggregationSpec: aggregationSpec,
        	      timezone: config.workspaceConfiguration.TimeZone,
        	      snapshotValidFromField: '_ValidFrom',
        	      snapshotValidToField: '_ValidTo',
        	      snapshotUniqueID: 'ObjectID'
        	    };
        	    _ref1 = lumenize.timeSeriesCalculator(results, timeSeriesCalculatorConfig), listOfAtCTs = _ref1.listOfAtCTs, aggregationAtArray = _ref1.aggregationAtArray;
//        	    console.log("aggregationAtArray: " + (JSON.stringify(aggregationAtArray, null, 2)));
        	    series = lumenize.aggregationAtArray_To_HighChartsSeries(aggregationAtArray, aggregationSpec);
        	    categories = (function() {
        	      var _j, _len1, _results;
        	      _results = [];
        	      for (_j = 0, _len1 = listOfAtCTs.length; _j < _len1; _j++) {
        	        ct = listOfAtCTs[_j];
        	        _results.push("" + (ct.toString()));
                    if(ct.toString() === todayCT.toString()) {
                    	todayIndex = _j;
                    }
                    for(var k = 0; k<rDates.length; k++){
                    	if(ct.toString() === rDates[k].toString()){
                    		rIndex.push(_j);
                    	}
                    }
                  }
                  return _results;
        	    })();
        	    originalPointCount = categories.length;
        	    if (__indexOf.call(config.series, "ideal") >= 0) {
        	      i = 0;
        	      while (series[i].name.indexOf("Ideal") < 0) {
        	        i++;
        	      }
        	      idealData = series[i].data;
        	      maxTaskEstimateTotal = lumenize.functions.$max(idealData);
        	      idealStep = maxTaskEstimateTotal / (originalPointCount - 1);
        	      for (i = _j = 0, _ref2 = originalPointCount - 2; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
        	        idealData[i] = (originalPointCount - 1 - i) * idealStep;
        	      }
        	      idealData[originalPointCount - 1] = 0;
        	    }
                if (__indexOf.call(config.series, "projection") >= 0) {
                    i = 0;
                    while (series[i].name.indexOf("Ideal (Points)") < 0) {
                      i++;
                    }
                    var j = 0;
                    while (series[j].name.indexOf("Accepted") < 0) {
                        j++;
                    }
                    var upData = series[j].data;
                    idealData = series[i].data;
                    
                    if(todayIndex >= 0) {
	                    //calculate ideal burn up line based on previous X number of days
	                    var numDays = 42;
	                    var delta = Math.floor((upData[todayIndex] - upData[todayIndex-numDays])/numDays);
	                    idealData[todayIndex] = upData[todayIndex];
	                    for (i = 0; i<idealData.length; i++) {
	                    	if(i < todayIndex) {
	                    		idealData[i] = null;
	                    	} else if (i > todayIndex){
	                            idealData[i] = idealData[i-1] + delta;
	                    	}
	                    }
	                    for (i = todayIndex+1; i<upData.length; i++) {
	                        upData[i] = null;
	                    }
                    }
                }
                	
                if (__indexOf.call(config.series, "rDates") >= 0) {
                    i = 0;
                    while (series[i].name.indexOf("Release") < 0) {
                      i++;
                    }
                    var j = 0;
                    while (series[j].name.indexOf("Scope") < 0) {
                        j++;
                    }
                    var sData = series[j].data;
                    var rData = series[i].data;
                    
                    var sMax = lumenize.functions.$max(sData);
                    sMax = sMax + 250;
                    
                    for(i=0; i<rData.length; i++){
                    	for(j=0; j<rIndex.length; j++){
                    		if((i === (rIndex[j]-1))||(i === rIndex[j])){
                    			rData[i] = sMax;
                    			break;
                    		} else {
                    			rData[i] = null;
                    		}
                    	}
                    }
                  }
        	    return {
        	      categories: categories,
        	      series: series
        	    };
        	  };

        	  root.burnCalculator = burnCalculator;

        	}).call(this);
        	
            (function () {
            
                Ext.define('Rally.app.analytics.BurnChartBuilder', {
                    mixins:{
                        componentUpdatable:'Rally.util.ComponentUpdatable'
                    },
                    build:function (requestedQuery, chartTitle, subTitle, buildFinishedCallback, config) {
            
                        this.chartTitle = chartTitle;
                        this.subTitle = subTitle;
                        this.buildFinishedCallback = buildFinishedCallback;
                        this.startTime = config.startDate;
                        this.endTime = config.endDate;
                        this.rDates = config.releaseDates;
                        this.query = {
                            find:Ext.encode(requestedQuery.find),
                            start:1,
                            pagesize:20000 //MAX_PAGESIZE  //10000
                        };
                        this.results = null;
                        this.requestedFields = Ext.Array.union(['_ValidFrom', '_ValidTo', 'ObjectID', 'ScheduleState', 'PlanEstimate'], requestedQuery.fields ? requestedQuery.fields : []);
            
                        this.workspace = Rally.util.Ref.getOidFromRef(Rally.environment.getContext().context.scope.workspace._ref);
            
                        if (this.scheduleStateOidAccepted && this.scheduleStateOidReleased) {
                            this._queryAnalyticsApi();
                        } else {
                            //mark this component that its updating multiple ajax requests. See Rally.util.ComponentUpdatable mixin.
                            var acceptedReqName = 'GetAcceptedScheduleStateOid';
                            var releasedReqName = 'GetReleasedScheduleStateOid';
                            //mark which requests need to be made
                            if (!this.scheduleStateOidAccepted) {
                                this.markUpdating(acceptedReqName);
                            }
                            if (!this.scheduleStateOidReleased) {
                                this.markUpdating(releasedReqName);
                            }
                            //now make requests
                            if (!this.scheduleStateOidAccepted) {
                                this._getScheduleStateOid('Accepted', acceptedReqName);
                            }
                            if (!this.scheduleStateOidReleased) {
                                this._getScheduleStateOid('Released', releasedReqName);
                            }
                        }
            
                    },
            
                    _afterAllScheduleStateOidsReturned:function () {
                        this._queryAnalyticsApi();
                    },
            
                    _queryAnalyticsApi:function () {
                        Ext.Ajax.request({
                            url:"https://rally1.rallydev.com/analytics/v2.0/service/rally/workspace/" + this.workspace + "/artifact/snapshot/query.js?" + Ext.Object.toQueryString(this.query) +
                                "&fields=" + JSON.stringify(this.requestedFields) + "&sort={_ValidFrom:1}",
                            method:"GET",
                            //need to change this to a POST
                            success:function (response) {
                                this._afterQueryReturned(JSON.parse(response.responseText));
                            },
                            scope:this
                        });
                    },
            
                    _getScheduleStateOid:function (state, reqName) {
                        var workspace = Rally.util.Ref.getOidFromRef(Rally.environment.getContext().context.scope.workspace._ref);
                        var project = Rally.util.Ref.getOidFromRef(Rally.environment.getContext().context.scope.project._ref);
                        var analyticsScheduleStateQuery = "find={ScheduleState:'" + state + "'}&fields=['ScheduleState']&pagesize=1";
                        Ext.Ajax.request({
                            url:"https://rally1.rallydev.com/analytics/v2.0/service/rally/workspace/" + workspace + "/artifact/snapshot/query.js?" + analyticsScheduleStateQuery,
                            method:"GET",
                            success:function (response) {
                                var results = JSON.parse(response.responseText).Results;
                                if (results.length > 0) {
                                    this['scheduleStateOid' + state] = results[0].ScheduleState;
                                }
                                this.markUpdated(reqName, this._afterAllScheduleStateOidsReturned, this);
                            },
                            scope:this
                        });
                    },
            
                    _afterQueryReturned:function (queryResultsData) {
                    	var count = 0;
                    	if (queryResultsData.TotalResultCount > 0) {
                        	if(queryResultsData.TotalResultCount >= 20000+this.query.start-1) {
                        		if(this.results == null)
                        			this.results = queryResultsData.Results;
                        		else
                        			this.results = this.results.concat(queryResultsData.Results);
                        		count = this.results.length;
                        		this.query.start = this.query.start+20000;
                        		this._queryAnalyticsApi();
                        	}
                        	else {
                        		if(this.results == null)
                        			this.results = queryResultsData.Results;
                        		else
                        			this.results = this.results.concat(queryResultsData.Results);
                        		count = this.results.length;
                        		this._buildChartConfigAndCallback(this.results,queryResultsData.ETLDate);
                        	}
                        } else {
                            this.buildFinishedCallback(false);
                        }
                    },
                    
                    _collect:function() {
                    	  var ret = {};
                    	  var len = arguments.length;
                    	  for (var i=0; i<len; i++) {
                    	    for (p in arguments[i]) {
                    	      if (arguments[i].hasOwnProperty(p)) {
                    	        ret[p] = arguments[i][p];
                    	      }
                    	    }
                    	  }
                    	  return ret;
                    },
            
                    _buildChartConfigAndCallback: function(queryResultsData,today) {
                        var lumenize = require('./lumenize');
                            var contextWorkspaceConfig = Rally.environment.getContext().context.scope.workspace.WorkspaceConfiguration;
                            var workspaceConfiguration = {
                                // Need to grab from Rally for this user
                                DateFormat:contextWorkspaceConfig.DateFormat,
                                DateTimeFormat:contextWorkspaceConfig.DateTimeFormat,
                                //TODO: Have context code fetch these values for the workspace config, instead of hardcoding them
                                IterationEstimateUnitName:'Points',
                                // !TODO: Should we use this?
                                ReleaseEstimateUnitName:'Points',
                                TaskUnitName:'Hours',
                                TimeTrackerEnabled:true,
                                TimeZone:'America/Denver',
                                WorkDays:'Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'
                                // They work on weekends
                            };
            
                            var acceptedStates = [];
                            if( this.scheduleStateOidAccepted ){
                                acceptedStates.push( this.scheduleStateOidAccepted );
                            }
                            if( this.scheduleStateOidReleased ){
                                acceptedStates.push( this.scheduleStateOidReleased );
                            }
            
                            var burnConfig = {
                            	today:today,
                                workspaceConfiguration:workspaceConfiguration,
                                upSeriesType:'Points',
                                // 'Points' or 'Story Count'
                                series:[
                                    'up',
                                    'scope',
                                    'projection',
                                    'rDates'
                                ],
            
                                acceptedStates:acceptedStates,
                                start:this.startTime,
                                end:this.endTime,
                                rDates:this.rDates,
                                // Calculated either by inspecting results or via configuration. pastEnd is automatically the last date in results
                                holidays:[
                                    {
                                        month:12,
                                        day:25
                                    },
                                    {
                                        month:11,
                                        day:26
                                    },
                                    {
                                        month:1,
                                        day:18
                                    }
                                ]
                            };
                        	//loop through and check for missing lookback data  
                        	for(var i = 0; i < queryResultsData.length; i++){
                        		if(!queryResultsData[i].hasOwnProperty('PlanEstimate')) {
                        			queryResultsData[i]['PlanEstimate'] = 0;
                        	    }
                        		if(!queryResultsData[i].hasOwnProperty('ScheduleState')) {
                        			queryResultsData[i]['ScheduleState'] = 0;
                        	    }
                        	}
            
//                            lumenize.ChartTime.setTZPath("");
                            var tscResults = burnCalculator(queryResultsData, burnConfig);
            
                            var categories = tscResults.categories;
                            var series = tscResults.series;
                            var chartConfiguration = {
                                chart:{
                                    defaultSeriesType:'column',
                                    zoomType: 'xy'
                                },
                                credits:{
                                    enabled:false
                                },
                                title:{
                                    text:this.chartTitle
                                },
                                subtitle:{
                                    text:this.subTitle
                                },
                                xAxis:{
                                    categories:categories,
                                    tickmarkPlacement:'on',
                                    tickInterval:Math.floor(categories.length / 13) + 1,
                                    // set as a function of the length of categories
                                    title:{
                                        enabled:false
                                    }
                                },
                                yAxis:{
                                        title:{
                                            text:'Points'
                                        },
                                        labels:{
                                            formatter:function () {
                                                return this.value / 1;
                                            }
                                        },
                                        min:0
                                    },
            //                        {
            //                            title:{
            //                                text:burnConfig.upSeriesType
            //                            },
            //                            opposite:true,
            //                            labels:{
            //                                formatter:function () {
            //                                    return this.value / 1;
            //                                }
            //                            },
            //                            min:0
            //                        }
            //                    ],
                                tooltip:{
                                    formatter:function () {
                                        return '' + this.x + '<br />' + this.series.name + ': ' + this.y;
                                    }
                                },
                                plotOptions:{
                                    column:{
                                        stacking:null,
                                        lineColor:'#666666',
                                        lineWidth:2,
                                        marker:{
                                            lineWidth:1,
                                            lineColor:'#666666'
                                        }
                                    },
                                    area:{
                                        lineWidth:2,
                                        marker:{
                                        	enabled: false,
                                            lineWidth:1,
                                            lineColor:'#666666'
                                        }
                                    },
                                    line:{
                                        lineWidth:2,
                                        marker:{
                                        	enabled: false,
                                            lineWidth:1,
                                            lineColor:'#666666'
                                        }
                                    }
                                },
                                series:series
                            };
            
                            this.buildFinishedCallback(true, chartConfiguration);
                    }
                });
            })();            
            
            Ext.define('EnterpriseReleaseApp', {
                extend:'Rally.app.App',
                mixins: {
                    messageable: 'Rally.Messageable'
                },
                appName:'Enterprise Release',
                cls:'burnchart',
        		items: [
        		        { xtype: 'container', itemId: 'dropdownDiv' },
        		        { xtype: 'container', itemId: 'buttonDiv' },
        		        { xtype: 'container', itemId: 'chartDiv' }
        		    ],
                
                launch: function () {
            
                	this.sDate = new Date();
            		this.sDate.setYear(2100);
            		this.eDate = new Date(0);
            		this.rDates = new Array();
            		this.programName = "";
            		this.releaseName = "";
            		this.projectName = "";

                	this.down('#dropdownDiv').add({
                		xtype: 'rallycombobox',
                		fieldLabel: 'Select an Enterprise Release',
                		width: '500px',
//                		renderTo: Ext.get("dropdownDiv"),
            	        storeConfig: {
            	            autoLoad: true,
            	            model: 'Program',
            	            fetch: 'Name,Releases,ReleaseStartDate,ReleaseDate',
    	        		    sorters: [
    	        		              {
    	        		                  property: 'Name',
    	        		                  direction: 'ASC'
    	        		              }
    	        		    ]
            	        },
            	        listeners: {
            	            select: this._onSelect,
            	            scope: this
            	        }
                	});
                	this.down('#buttonDiv').add({
                        xtype: 'rallybutton',
                        text: 'Export',
//                		renderTo: Ext.get("buttonDiv"),
                        handler: function() {
                        	var canvas = document.getElementById("chartDiv");
//                        	var canvas = Ext.get("chartDiv");
                        	var img    = canvas.toDataURL("image/jpeg");
                        	document.write('<img src="'+img+'"/>');
                        }
                	});

                },
                
                _onSelect: function(comboBox, records) {
                	
                	var cmp = this.add({
                         id: 'loadCmp',
                         xtype: 'component',
                         flex: 1
                    });
                	cmp.setLoading('Building your chart...');

                	this.sDate = new Date();
            		this.sDate.setYear(2100);
            		this.eDate = new Date(0);
            		this.rDates = [];
            		this.programName = "";
            		this.projectName = "";
            		this.releaseName = "[ "
                	 
            		var oidReleaseArray = new Array();
            		this.programName = records[0].get('Name');
            		this.projectName = this.context.getProject()._refObjectName;
                	//loop through records, get min start date and max end date
            		var releases = new Array();
                	releases = records[0].get('Releases');
                	for(var i=0; i < releases.length; i++){
                		var myRelease = releases[i];
                		this.releaseName = this.releaseName + myRelease.Name + "  ";
                		this.rDates.push(new Date(Date.parse(myRelease.ReleaseDate)));
                		if(Date.parse(myRelease.ReleaseStartDate) < this.sDate)
                			this.sDate = new Date(Date.parse(myRelease.ReleaseStartDate));
                		if(Date.parse(myRelease.ReleaseDate) > this.eDate)
                			this.eDate = new Date(Date.parse(myRelease.ReleaseDate));
                	}
            		this.releaseName = this.releaseName + "]";
                	//temp work around for missing data
                	//this.sDate.setFullYear(2012, 02, 01);
                	filter = [];
                	for(var i = 0; i < releases.length; i++) {
                		var newFilter = new Rally.data.QueryFilter({
            				property: 'Name',
            				operator: '=',
            				value: releases[i]._refObjectName
            			});
                		
                		if(i == 0) {
                			filter = newFilter;
                		}
                		else {
                			filter = filter.or(newFilter);
                		}
                	}
                	var context = this.context.getDataContext();
                	context.projectScopeDown = true;
                	var releaseStore = Ext.create('Rally.data.WsapiDataStore', {
                		autoLoad: true,
                	    model: 'Release',
                	    filters: filter,
                	    fetch: 'ObjectID,Project',
                	    context: context,
                	    listeners: {
                	    	load: {
                	    		fn: this._onReleasesLoad,
                	    		scope: this
                	    	}
                	    }
                	});
                },
                
                _onReleasesLoad: function(store, data) {
                	var releases = [];
                	for(var i = 0; i < data.length; i++) {
                		releases.push(data[i].get('ObjectID')); 
                	}
                	//this.startTime = '2012-01-01T00:00:00Z';
                    this.chartQuery = {
                        find:{
                        	_TypeHierarchy : {'$in': ['HierarchicalRequirement','Defect']},
                            Children:null,
                            Release: {'$in': releases},
                            _ValidFrom: {
                                $gte: this.sDate //this.startTime
                            }
                        }
                    };
            
                    this.chartConfigBuilder = Ext.create('Rally.app.analytics.BurnChartBuilder');
                    this.chartConfigBuilder.build(this.chartQuery, this.programName, this.projectName, Ext.bind(this._afterChartConfigBuilt, this), {
                    	startDate: this.sDate,
                    	endDate: this.eDate,
                    	releaseDates: this.rDates
                    });
                },
            
                _afterChartConfigBuilt: function (success, chartConfig) {
                    this._removeChartComponent();
                    if (success){
                        this.down('#chartDiv').add({
                            id: 'chartCmp',
                            xtype: 'rallychart',
//                    		renderTo: Ext.get("chartDiv"),
                            flex: 1,
                            chartConfig: chartConfig
                        });
                    } else {
                        //var formattedId = this.selectedRowRecord.get('FormattedID');
                        this.add({
                            id: 'chartCmp',
                            xtype: 'component',
                            html: '<div>No data found starting from: ' + this.sDate + '</div>'
                        });
                    }
                },
            
                _removeChartComponent: function() {
                    var chartCmp = this.down('#chartCmp');
                    if (chartCmp) {
                        this.remove(chartCmp);
                    }
                    
                    var loadCmp = this.down('#loadCmp');
                    if (loadCmp) {
                    	this.remove(loadCmp);
                    }
                },
            
                _onTreeRowAdd: function(tree, treeRow) {
                    treeRow.on('afterrender', this._afterTreeRowRendered, this);
                },
            
                _afterTreeRowRendered: function(treeRow) {
                    treeRow.getEl().on('click', this._onTreeRowClick, this, {stopEvent: true});
                },
            
                _onTreeRowClick: function(event, treeRowTextEl) {
                    var treeItem = Ext.getCmp(Ext.get(treeRowTextEl).findParentNode('.treeItem').id);
                    var treeRowRecord = treeItem.getRecord();
                    var itemId = treeRowRecord.get('ObjectID');
                    var title = treeRowRecord.get('FormattedID') + ' - ' + treeRowRecord.get('Name');
                    this._refreshChart(treeRowRecord, itemId, title);
                },
            
                _refreshChart: function(treeRowRecord, itemId, title) {
                    this.selectedRowRecord = treeRowRecord;
                    this.chartQuery.find._ItemHierarchy = itemId;
                    this.down('#chartCmp').getEl().mask('Loading...');
                    this.chartConfigBuilder.build(this.chartQuery, title, Ext.bind(this._afterChartConfigBuilt, this));
                }
            });

            Rally.launchApp('EnterpriseReleaseApp', {
                name: 'EnterpriseReleaseApp'
            });
        });
    </script>

    <style type="text/css">
        .app {
        
        }
        
        .rallytree {
            overflow: auto;
        }
        
        .treeItem .pill .row-action {
            display: none;
        }
        
        .treeItem .pill {
            cursor: pointer;
        }
        
        .rui-triggerfield {
        	height: 20px !important;
        	width: 310px !important;
        	margin-left: 10px;
        }
        
        .x-field-label-cell {
        	width: 150px !important;
        }
        
        .x-form-item-label {
        	width: 145px !important;
        }
        
        .x-mask-msg {
        	top: 100px !important;
        }
        
        .x-css-shadow {
        	top: -1100px !important;
        }    </style>
</head>
<body>
    <table>
        <tr>
            <td>
                <div id="dropdownDiv" style="height:50px; width:500px;"></div>
            </td>
            <td>
                <div id="buttonDiv" style="height:50px; width:50px;"></div>
            </td>
        </tr>
	</table>
   <div id="chartDiv"></div>
</body>
</html>
